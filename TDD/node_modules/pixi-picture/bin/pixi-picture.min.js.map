{"version":3,"sources":["../pixify/node_modules/browser-pack/_prelude.js","src/HardLightShader.js","src/NormalShader.js","src/OverlayShader.js","src/PictureRenderer.js","src/PictureShader.js","src/PictureSprite.js","src/PictureTilingSprite.js","src/mapFilterBlendModesToPixi.js","src"],"names":["f","exports","module","define","amd","g","window","global","self","this","pixiPicture","min","e","t","n","r","s","o","u","a","require","i","Error","code","l","call","length","1","HardLightShader","gl","tilingMode","PictureShader","bind","uniforms","uSampler","prototype","Object","create","constructor","NormalShader","uColor","Float32Array","OverlayShader","PictureRenderer","renderer","PIXI","ObjectRenderer","nextPow2","v","mapFilterBlendModesToPixi","WRAP_MODES","glCore","onContextChange","quad","Quad","drawModes","normalShader","initVao","_tempClamp","_tempColor","_tempRect","Rectangle","_tempRect2","_tempRect3","_tempMatrix","Matrix","_tempMatrix2","_bigBuf","Uint8Array","_renderTexture","BaseRenderTexture","start","flush","_getRenderTexture","minWidth","minHeight","width","height","resize","_getBuf","size","buf","render","sprite","texture","valid","tileTransform","_isSimpleSprite","blendShader","blendMode","_renderBlend","_renderNormal","shader","bindShader","state","setBlendMode","_renderInner","spriteBounds","getBounds","renderTarget","_activeRenderTarget","matrix","projectionMatrix","flipX","flipY","d","resolution","screen","fr","sourceFrame","destinationFrame","x","y","bounds","fbw","fbh","tx","ty","x_1","Math","floor","max","x_2","ceil","y_1","y_2","pixelsWidth","pixelsHeight","rt","bindTexture","renderingToScreen","root","readPixels","RGBA","UNSIGNED_BYTE","texSubImage2D","TEXTURE_2D","copyTexSubImage2D","BLEND_MODES","NORMAL","mapMatrix","toArray","_renderWithShader","_renderSprite","uvs","_uvs","vd","vertices","computedGeometry","vertexData","x0","y0","x1","y1","x2","y2","x3","y3","upload","frame","base","baseTexture","clamp","eps","uTextureClamp","color","utils","hex2rgb","tint","alpha","worldAlpha","draw","ts","tex","_texture","baseTex","isSimple","isPowerOfTwo","_glTextures","CONTEXT_UID","wrapMode","CLAMP","REPEAT","w0","_width","_anchor","_x","w1","h0","_height","_y","h1","wt","transform","worldTransform","b","c","anchor","lt","localTransform","uv","uvTransform","w","h","W","H","tempMat","set","invert","append","mapCoord","uMapCoord","uClampFrame","uClampOffset","uTransform","WebGLRenderer","registerPlugin","vert","frag","lib","shaderLib","Shader","replace","vertUniforms","vertCode","fragUniforms","fragCode","PictureSprite","Sprite","_renderWebGL","updateGeometry","calculateVertices","setObjectRenderer","plugins","picture","PictureTilingSprite","extras","TilingSprite","updateLocalTransform","update","array","CONST","OVERLAY","HARD_LIGHT","myPlugin","assign"],"mappings":"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","file":"pixi-picture.min.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","\r\nvar PictureShader = require('./PictureShader');\r\n\r\n/**\r\n * @class\r\n * @extends PIXI.Shader\r\n * @memberof PIXI.extras\r\n * @param gl {PIXI.Shader} The WebGL shader manager this shader works for.\r\n * @param tilingMode {number} 0 for default, 1 for simple tiling, 2 for tiling\r\n */\r\nfunction HardLightShader(gl, tilingMode)\r\n{\r\n    PictureShader.call(this,\r\n        gl,\r\n        \"#define GLSLIFY 1\\nattribute vec2 aVertexPosition;\\nattribute vec2 aTextureCoord;\\nattribute vec4 aColor;\\n\\nuniform mat3 projectionMatrix;\\nuniform mat3 mapMatrix;\\n\\nvarying vec2 vTextureCoord;\\nvarying vec2 vMapCoord;\\n%SPRITE_UNIFORMS%\\n\\nvoid main(void)\\n{\\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\\n    %SPRITE_CODE%\\n    vMapCoord = (mapMatrix * vec3(aVertexPosition, 1.0)).xy;\\n}\\n\",\r\n        \"#define GLSLIFY 1\\nvarying vec2 vTextureCoord;\\nvarying vec2 vMapCoord;\\nvarying vec4 vColor;\\n\\nuniform sampler2D uSampler[2];\\nuniform vec4 uColor;\\n%SPRITE_UNIFORMS%\\n\\nvoid main(void)\\n{\\n    %SPRITE_CODE%\\n    vec4 source = texture2D(uSampler[0], textureCoord) * uColor;\\n    vec4 target = texture2D(uSampler[1], vMapCoord);\\n\\n    //reverse hardlight\\n    if (source.a == 0.0) {\\n        gl_FragColor = vec4(0, 0, 0, 0);\\n        return;\\n    }\\n    //yeah, premultiplied\\n    vec3 Cb = source.rgb/source.a, Cs;\\n    if (target.a > 0.0) {\\n        Cs = target.rgb / target.a;\\n    }\\n    vec3 multiply = Cb * Cs * 2.0;\\n    vec3 Cs2 = Cs * 2.0 - 1.0;\\n    vec3 screen = Cb + Cs2 - Cb * Cs2;\\n    vec3 B;\\n    if (Cb.r <= 0.5) {\\n        B.r = multiply.r;\\n    } else {\\n        B.r = screen.r;\\n    }\\n    if (Cb.g <= 0.5) {\\n        B.g = multiply.g;\\n    } else {\\n        B.g = screen.g;\\n    }\\n    if (Cb.b <= 0.5) {\\n        B.b = multiply.b;\\n    } else {\\n        B.b = screen.b;\\n    }\\n    vec4 res;\\n    res.xyz = (1.0 - source.a) * Cs + source.a * B;\\n    res.a = source.a + target.a * (1.0-source.a);\\n    gl_FragColor = vec4(res.xyz * res.a, res.a);\\n}\\n\",\r\n        tilingMode\r\n    );\r\n    this.bind();\r\n    this.uniforms.uSampler = [0, 1];\r\n}\r\n\r\nHardLightShader.prototype = Object.create(PictureShader.prototype);\r\nHardLightShader.prototype.constructor = HardLightShader;\r\nmodule.exports = HardLightShader;\r\n","\r\nvar PictureShader = require('./PictureShader');\r\n\r\n/**\r\n * @class\r\n * @extends PIXI.Shader\r\n * @memberof PIXI.extras\r\n * @param gl {PIXI.Shader} The WebGL shader manager this shader works for.\r\n * @param tilingMode {number} 0 for default, 1 for simple tiling, 2 for tiling\r\n */\r\nfunction NormalShader(gl, tilingMode)\r\n{\r\n    PictureShader.call(this,\r\n        gl,\r\n        \"#define GLSLIFY 1\\nattribute vec2 aVertexPosition;\\nattribute vec2 aTextureCoord;\\nattribute vec4 aColor;\\n\\nuniform mat3 projectionMatrix;\\n\\nvarying vec2 vTextureCoord;\\n%SPRITE_UNIFORMS%\\n\\nvoid main(void)\\n{\\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\\n    %SPRITE_CODE%\\n}\\n\",\r\n        \"#define GLSLIFY 1\\nvarying vec2 vTextureCoord;\\nvarying vec4 vColor;\\n\\nuniform sampler2D uSampler;\\nuniform vec4 uColor;\\n%SPRITE_UNIFORMS%\\n\\nvoid main(void)\\n{\\n    %SPRITE_CODE%\\n\\n    vec4 sample = texture2D(uSampler, textureCoord);\\n    gl_FragColor = sample * uColor;\\n}\\n\",\r\n        tilingMode\r\n    );\r\n    //do some stuff, like default values for shader\r\n    //dont forget to bind it if you really are changing the uniforms\r\n    this.bind();\r\n    //default tint\r\n    //Its an example, actually PictureRenderer takes care of this stuff\r\n    this.uniforms.uColor = new Float32Array(1,1,1,1);\r\n}\r\n\r\nNormalShader.prototype = Object.create(PictureShader.prototype);\r\nNormalShader.prototype.constructor = NormalShader;\r\nmodule.exports = NormalShader;\r\n","\r\nvar PictureShader = require('./PictureShader');\r\n\r\n/**\r\n * @class\r\n * @extends PIXI.Shader\r\n * @memberof PIXI.extras\r\n * @param gl {PIXI.Shader} The WebGL shader manager this shader works for.\r\n * @param tilingMode {number} 0 for default, 1 for simple tiling, 2 for tiling\r\n */\r\nfunction OverlayShader(gl, tilingMode)\r\n{\r\n    PictureShader.call(this,\r\n        gl,\r\n        \"#define GLSLIFY 1\\nattribute vec2 aVertexPosition;\\nattribute vec2 aTextureCoord;\\nattribute vec4 aColor;\\n\\nuniform mat3 projectionMatrix;\\nuniform mat3 mapMatrix;\\n\\nvarying vec2 vTextureCoord;\\nvarying vec2 vMapCoord;\\n%SPRITE_UNIFORMS%\\n\\nvoid main(void)\\n{\\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\\n    %SPRITE_CODE%\\n    vMapCoord = (mapMatrix * vec3(aVertexPosition, 1.0)).xy;\\n}\\n\",\r\n        \"#define GLSLIFY 1\\nvarying vec2 vTextureCoord;\\nvarying vec2 vMapCoord;\\nvarying vec4 vColor;\\n\\nuniform sampler2D uSampler[2];\\nuniform vec4 uColor;\\n%SPRITE_UNIFORMS%\\n\\nvoid main(void)\\n{\\n    %SPRITE_CODE%\\n    vec4 source = texture2D(uSampler[0], textureCoord) * uColor;\\n    vec4 target = texture2D(uSampler[1], vMapCoord);\\n\\n    //reverse hardlight\\n    if (source.a == 0.0) {\\n        gl_FragColor = vec4(0, 0, 0, 0);\\n        return;\\n    }\\n    //yeah, premultiplied\\n    vec3 Cb = source.rgb/source.a, Cs;\\n    if (target.a > 0.0) {\\n        Cs = target.rgb / target.a;\\n    }\\n    vec3 multiply = Cb * Cs * 2.0;\\n    vec3 Cb2 = Cb * 2.0 - 1.0;\\n    vec3 screen = Cb2 + Cs - Cb2 * Cs;\\n    vec3 B;\\n    if (Cs.r <= 0.5) {\\n        B.r = multiply.r;\\n    } else {\\n        B.r = screen.r;\\n    }\\n    if (Cs.g <= 0.5) {\\n        B.g = multiply.g;\\n    } else {\\n        B.g = screen.g;\\n    }\\n    if (Cs.b <= 0.5) {\\n        B.b = multiply.b;\\n    } else {\\n        B.b = screen.b;\\n    }\\n    vec4 res;\\n    res.xyz = (1.0 - source.a) * Cs + source.a * B;\\n    res.a = source.a + target.a * (1.0-source.a);\\n    gl_FragColor = vec4(res.xyz * res.a, res.a);\\n}\\n\",\r\n        tilingMode\r\n    );\r\n    this.bind();\r\n    this.uniforms.uSampler = [0, 1];\r\n}\r\n\r\nOverlayShader.prototype = Object.create(PictureShader.prototype);\r\nOverlayShader.prototype.constructor = OverlayShader;\r\nmodule.exports = OverlayShader;\r\n","var NormalShader = require('./NormalShader'),\r\n    mapFilterBlendModesToPixi = require('./mapFilterBlendModesToPixi'),\r\n    glCore = PIXI.glCore,\r\n    WRAP_MODES = PIXI.WRAP_MODES;\r\n\r\n/**\r\n * Renderer that clamps the texture so neighbour frames wont bleed on it\r\n * immitates context2d drawImage behaviour\r\n *\r\n * @class\r\n * @memberof PIXI.extras\r\n * @extends PIXI.ObjectRenderer\r\n * @param renderer {PIXI.WebGLRenderer} The renderer this plugin works for\r\n */\r\nfunction PictureRenderer(renderer) {\r\n    PIXI.ObjectRenderer.call(this, renderer);\r\n}\r\n\r\nPictureRenderer.prototype = Object.create(PIXI.ObjectRenderer.prototype);\r\nPictureRenderer.prototype.constructor = PictureRenderer;\r\n\r\nPictureRenderer.prototype.onContextChange = function () {\r\n    var gl = this.renderer.gl;\r\n    this.quad = new PIXI.Quad(gl);\r\n    this.drawModes = mapFilterBlendModesToPixi(gl);\r\n    this.normalShader = [new NormalShader(gl, 0), new NormalShader(gl, 1), new NormalShader(gl, 2)];\r\n    this.quad.initVao(this.normalShader[0]);\r\n    this._tempClamp = new Float32Array(4);\r\n    this._tempColor = new Float32Array(4);\r\n    this._tempRect = new PIXI.Rectangle();\r\n    this._tempRect2 = new PIXI.Rectangle();\r\n    this._tempRect3 = new PIXI.Rectangle();\r\n    this._tempMatrix = new PIXI.Matrix();\r\n    this._tempMatrix2 = new PIXI.Matrix();\r\n    this._bigBuf = new Uint8Array(1 << 20);\r\n    this._renderTexture = new PIXI.BaseRenderTexture(1024, 1024);\r\n};\r\n\r\nPictureRenderer.prototype.start = function () {\r\n    //noop\r\n};\r\n\r\nPictureRenderer.prototype.flush = function () {\r\n    //noop\r\n};\r\n\r\nfunction nextPow2(v) {\r\n    v += v === 0;\r\n    --v;\r\n    v |= v >>> 1;\r\n    v |= v >>> 2;\r\n    v |= v >>> 4;\r\n    v |= v >>> 8;\r\n    v |= v >>> 16;\r\n    return v + 1;\r\n}\r\n\r\nPictureRenderer.prototype._getRenderTexture = function (minWidth, minHeight) {\r\n    if (this._renderTexture.width < minWidth ||\r\n        this._renderTexture.height < minHeight) {\r\n        minHeight = nextPow2(minWidth);\r\n        minHeight = nextPow2(minHeight);\r\n        this._renderTexture.resize(minWidth, minHeight);\r\n    }\r\n    return this._renderTexture;\r\n};\r\n\r\nPictureRenderer.prototype._getBuf = function (size) {\r\n    var buf = this._bigBuf;\r\n    if (buf.length < size) {\r\n        size = nextPow2(size);\r\n        buf = new Uint8Array(size);\r\n        this._bigBuf = buf;\r\n    }\r\n    return buf;\r\n};\r\n\r\n/**\r\n * Renders the picture object.\r\n *\r\n * @param sprite {PIXI.tilemap.PictureSprite} the picture to render\r\n */\r\nPictureRenderer.prototype.render = function (sprite) {\r\n    if (!sprite.texture.valid) {\r\n        return;\r\n    }\r\n    var tilingMode = 0;\r\n    if (sprite.tileTransform) {\r\n        //for TilingSprite\r\n        tilingMode = this._isSimpleSprite(sprite) ? 1 : 2;\r\n    }\r\n\r\n    var blendShader = this.drawModes[sprite.blendMode];\r\n    if (blendShader) {\r\n        this._renderBlend(sprite, blendShader[tilingMode]);\r\n    } else {\r\n        this._renderNormal(sprite, this.normalShader[tilingMode]);\r\n    }\r\n};\r\n\r\nPictureRenderer.prototype._renderNormal = function (sprite, shader) {\r\n    var renderer = this.renderer;\r\n    renderer.bindShader(shader);\r\n    renderer.state.setBlendMode(sprite.blendMode);\r\n    this._renderInner(sprite, shader);\r\n};\r\n\r\nPictureRenderer.prototype._renderBlend = function (sprite, shader) {\r\n    //nothing there yet\r\n    var renderer = this.renderer;\r\n    var spriteBounds = sprite.getBounds();\r\n    var renderTarget = renderer._activeRenderTarget;\r\n    var matrix = renderTarget.projectionMatrix;\r\n    var flipX = matrix.a < 0;\r\n    var flipY = matrix.d < 0;\r\n    var resolution = renderTarget.resolution;\r\n    var screen = this._tempRect;\r\n    var fr = renderTarget.sourceFrame || renderTarget.destinationFrame;\r\n    screen.x = 0;\r\n    screen.y = 0;\r\n    screen.width = fr.width;\r\n    screen.height = fr.height;\r\n\r\n    var bounds = this._tempRect2;\r\n    var fbw = fr.width * resolution, fbh = fr.height * resolution;\r\n    bounds.x = (spriteBounds.x + matrix.tx / matrix.a) * resolution + fbw / 2;\r\n    bounds.y = (spriteBounds.y + matrix.ty / matrix.d) * resolution + fbh / 2;\r\n    bounds.width = spriteBounds.width * resolution;\r\n    bounds.height = spriteBounds.height * resolution;\r\n    if (flipX) {\r\n        bounds.y = fbw - bounds.width - bounds.x;\r\n    }\r\n    if (flipY) {\r\n        bounds.y = fbh - bounds.height - bounds.y;\r\n    }\r\n\r\n    var screenBounds = this._tempRect3;\r\n    var x_1 = Math.floor(Math.max(screen.x, bounds.x));\r\n    var x_2 = Math.ceil(Math.min(screen.x + screen.width, bounds.x + bounds.width));\r\n    var y_1 = Math.floor(Math.max(screen.y, bounds.y));\r\n    var y_2 = Math.ceil(Math.min(screen.y + screen.height, bounds.y + bounds.height));\r\n    var pixelsWidth = x_2 - x_1;\r\n    var pixelsHeight = y_2 - y_1;\r\n    if (pixelsWidth <= 0 || pixelsHeight <= 0) {\r\n        //culling\r\n        return;\r\n    }\r\n    //TODO: padding\r\n    var rt = this._getRenderTexture(pixelsWidth, pixelsHeight);\r\n    renderer.bindTexture(rt, 1);\r\n    var gl = renderer.gl;\r\n    if (renderer.renderingToScreen && renderTarget.root) {\r\n        var buf = this._getBuf(pixelsWidth * pixelsHeight * 4);\r\n        gl.readPixels(x_1, y_1, pixelsWidth, pixelsHeight, gl.RGBA, gl.UNSIGNED_BYTE, this._bigBuf);\r\n        //REVERT Y?\r\n        gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, pixelsWidth, pixelsHeight, gl.RGBA, gl.UNSIGNED_BYTE, this._bigBuf);\r\n    } else {\r\n        gl.copyTexSubImage2D(gl.TEXTURE_2D, 0, 0, 0, x_1, y_1, pixelsWidth, pixelsHeight);\r\n    }\r\n\r\n    renderer.bindShader(shader);\r\n    renderer.state.setBlendMode(PIXI.BLEND_MODES.NORMAL);\r\n    if (shader.uniforms.mapMatrix) {\r\n        var mapMatrix = this._tempMatrix;\r\n        mapMatrix.a = bounds.width / rt.width / spriteBounds.width;\r\n        if (flipX) {\r\n            mapMatrix.a = -mapMatrix.a;\r\n            mapMatrix.tx = (bounds.x - x_1) / rt.width - (spriteBounds.x + spriteBounds.width) * mapMatrix.a;\r\n        } else {\r\n            mapMatrix.tx = (bounds.x - x_1) / rt.width - spriteBounds.x * mapMatrix.a;\r\n        }\r\n        mapMatrix.d = bounds.height / rt.height / spriteBounds.height;\r\n        if (flipY) {\r\n            mapMatrix.d = -mapMatrix.d;\r\n            mapMatrix.ty = (bounds.y - y_1) / rt.height - (spriteBounds.y + spriteBounds.height) * mapMatrix.d;\r\n        } else {\r\n            mapMatrix.ty = (bounds.y - y_1) / rt.height - spriteBounds.y * mapMatrix.d;\r\n        }\r\n\r\n        shader.uniforms.mapMatrix = mapMatrix.toArray(true);\r\n    }\r\n\r\n    this._renderInner(sprite, shader);\r\n};\r\n\r\nPictureRenderer.prototype._renderInner = function (sprite, shader) {\r\n    var renderer = this.renderer;\r\n    if (shader.tilingMode > 0) {\r\n        this._renderWithShader(sprite, shader.tilingMode === 1, shader);\r\n    } else {\r\n        this._renderSprite(sprite, shader);\r\n    }\r\n};\r\n\r\nPictureRenderer.prototype._renderSprite = function(sprite, shader) {\r\n    var renderer = this.renderer;\r\n    var quad = this.quad;\r\n    var uvs = sprite.texture._uvs;\r\n\r\n    //sprite already has calculated the vertices. lets transfer them to quad\r\n\r\n    var vertices = quad.vertices;\r\n    var vd = sprite.computedGeometry ? sprite.computedGeometry.vertices : sprite.vertexData;\r\n    for (var i = 0; i < 8; i++) {\r\n        quad.vertices[i] = vd[i];\r\n    }\r\n\r\n    //SpriteRenderer works differently, with uint32 UVS\r\n    //but for our demo float uvs are just fine\r\n    quad.uvs[0] = uvs.x0;\r\n    quad.uvs[1] = uvs.y0;\r\n    quad.uvs[2] = uvs.x1;\r\n    quad.uvs[3] = uvs.y1;\r\n    quad.uvs[4] = uvs.x2;\r\n    quad.uvs[5] = uvs.y2;\r\n    quad.uvs[6] = uvs.x3;\r\n    quad.uvs[7] = uvs.y3;\r\n\r\n    //TODO: add baricentric coords here\r\n    quad.upload();\r\n\r\n    var frame = sprite.texture.frame;\r\n    var base = sprite.texture.baseTexture;\r\n    var clamp = this._tempClamp;\r\n    //clamping 0.5 pixel from each side to reduce border artifact\r\n    //this is our plugin main purpose\r\n    var eps = 0.5 / base.resolution;\r\n    clamp[0] = (frame.x + eps) / base.width;\r\n    clamp[1] = (frame.y + eps) / base.height;\r\n    clamp[2] = (frame.x + frame.width - eps) / base.width;\r\n    clamp[3] = (frame.y + frame.height - eps) / base.height;\r\n    //take a notice that size in pixels is realWidth,realHeight\r\n    //width and height are divided by resolution\r\n    shader.uniforms.uTextureClamp = clamp;\r\n\r\n    var color = this._tempColor;\r\n    PIXI.utils.hex2rgb(sprite.tint, color);\r\n    var alpha = sprite.worldAlpha;\r\n    //premultiplied alpha tint\r\n    //of course we could do that in shader too\r\n    color[0] *= alpha;\r\n    color[1] *= alpha;\r\n    color[2] *= alpha;\r\n    color[3] = alpha;\r\n    shader.uniforms.uColor = color;\r\n\r\n    //bind texture to unit 0, our default sampler unit\r\n    renderer.bindTexture(base, 0);\r\n    quad.draw();\r\n};\r\n\r\n/**\r\n * this is a part of PIXI.extras.TilingSprite. It will be refactored later\r\n * @param ts\r\n * @returns {boolean}\r\n * @private\r\n */\r\nPictureRenderer.prototype._isSimpleSprite = function(ts) {\r\n    var renderer = this.renderer;\r\n    var tex = ts._texture;\r\n    var baseTex = tex.baseTexture;\r\n    var isSimple = baseTex.isPowerOfTwo && tex.frame.width === baseTex.width && tex.frame.height === baseTex.height;\r\n\r\n    // auto, force repeat wrapMode for big tiling textures\r\n    if (isSimple)\r\n    {\r\n        if (!baseTex._glTextures[renderer.CONTEXT_UID])\r\n        {\r\n            if (baseTex.wrapMode === WRAP_MODES.CLAMP)\r\n            {\r\n                baseTex.wrapMode = WRAP_MODES.REPEAT;\r\n            }\r\n        }\r\n        else\r\n        {\r\n            isSimple = baseTex.wrapMode !== WRAP_MODES.CLAMP;\r\n        }\r\n    }\r\n\r\n    return isSimple;\r\n};\r\n\r\n/**\r\n * this is a part of PIXI.extras.TilingSprite. It will be refactored later\r\n * @param ts\r\n * @returns {boolean}\r\n * @private\r\n */\r\nPictureRenderer.prototype._renderWithShader = function(ts, isSimple, shader)\r\n{\r\n    var quad = this.quad;\r\n    var vertices = quad.vertices;\r\n\r\n    var w0 = ts._width * (1 - ts._anchor._x);\r\n    var w1 = ts._width * -ts._anchor._x;\r\n\r\n    var h0 = ts._height * (1 - ts._anchor._y);\r\n    var h1 = ts._height * -ts._anchor._y;\r\n\r\n    var wt = ts.transform.worldTransform;\r\n\r\n    var a = wt.a;\r\n    var b = wt.b;\r\n    var c = wt.c;\r\n    var d = wt.d;\r\n    var tx = wt.tx;\r\n    var ty = wt.ty;\r\n\r\n    vertices[0] = (a * w1) + (c * h1) + tx;\r\n    vertices[1] = (d * h1) + (b * w1) + ty;\r\n\r\n    vertices[2] = (a * w0) + (c * h1) + tx;\r\n    vertices[3] = (d * h1) + (b * w0) + ty;\r\n\r\n    vertices[4] = (a * w0) + (c * h0) + tx;\r\n    vertices[5] = (d * h0) + (b * w0) + ty;\r\n\r\n    vertices[6] = (a * w1) + (c * h0) + tx;\r\n    vertices[7] = (d * h0) + (b * w1) + ty;\r\n\r\n    vertices = quad.uvs;\r\n\r\n    vertices[0] = vertices[6] = -ts.anchor.x;\r\n    vertices[1] = vertices[3] = -ts.anchor.y;\r\n\r\n    vertices[2] = vertices[4] = 1.0 - ts.anchor.x;\r\n    vertices[5] = vertices[7] = 1.0 - ts.anchor.y;\r\n\r\n    quad.upload();\r\n\r\n    var renderer = this.renderer;\r\n    var tex = ts._texture;\r\n    var lt = ts.tileTransform.localTransform;\r\n    var uv = ts.uvTransform;\r\n\r\n    var w = tex.width;\r\n    var h = tex.height;\r\n    var W = ts._width;\r\n    var H = ts._height;\r\n\r\n    var tempMat = this._tempMatrix2;\r\n\r\n    tempMat.set(lt.a * w / W,\r\n        lt.b * w / H,\r\n        lt.c * h / W,\r\n        lt.d * h / H,\r\n        lt.tx / W,\r\n        lt.ty / H);\r\n\r\n    // that part is the same as above:\r\n    // tempMat.identity();\r\n    // tempMat.scale(tex.width, tex.height);\r\n    // tempMat.prepend(lt);\r\n    // tempMat.scale(1.0 / ts._width, 1.0 / ts._height);\r\n\r\n    tempMat.invert();\r\n    if (isSimple)\r\n    {\r\n        tempMat.append(uv.mapCoord);\r\n    }\r\n    else\r\n    {\r\n        shader.uniforms.uMapCoord = uv.mapCoord.toArray(true);\r\n        shader.uniforms.uClampFrame = uv.uClampFrame;\r\n        shader.uniforms.uClampOffset = uv.uClampOffset;\r\n    }\r\n    shader.uniforms.uTransform = tempMat.toArray(true);\r\n\r\n    var color = this._tempColor;\r\n    var alpha = ts.worldAlpha;\r\n\r\n    PIXI.utils.hex2rgb(ts.tint, color);\r\n    color[0] *= alpha;\r\n    color[1] *= alpha;\r\n    color[2] *= alpha;\r\n    color[3] = alpha;\r\n    shader.uniforms.uColor = color;\r\n\r\n    renderer.bindTexture(tex);\r\n\r\n    quad.draw();\r\n};\r\n\r\nPIXI.WebGLRenderer.registerPlugin('picture', PictureRenderer);\r\n\r\nmodule.exports = PictureRenderer;\r\n","/**\r\n * @class\r\n * @extends PIXI.Shader\r\n * @memberof PIXI.extras\r\n * @param gl {PIXI.Shader} The WebGL shader manager this shader works for.\r\n * @param vert {string}\r\n * @param frag {string}\r\n * @param tilingMode {number} 0 for default, 1 for simple tiling, 2 for tiling\r\n */\r\nfunction PictureShader(gl, vert, frag, tilingMode) {\r\n    var lib = shaderLib[tilingMode];\r\n    PIXI.Shader.call(this,\r\n        gl,\r\n        vert.replace(/%SPRITE_UNIFORMS%/gi, lib.vertUniforms)\r\n            .replace(/%SPRITE_CODE%/gi, lib.vertCode),\r\n        frag.replace(/%SPRITE_UNIFORMS%/gi, lib.fragUniforms)\r\n            .replace(/%SPRITE_CODE%/gi, lib.fragCode)\r\n    );\r\n\r\n    this.tilingMode = tilingMode;\r\n}\r\n\r\n\r\nvar shaderLib = [\r\n    {\r\n        //DOES NOT HAVE translationMatrix\r\n        vertUniforms: \"\",\r\n        vertCode: \"vTextureCoord = aTextureCoord;\",\r\n        fragUniforms: \"uniform vec4 uTextureClamp;\",\r\n        fragCode: \"vec2 textureCoord = clamp(vTextureCoord, uTextureClamp.xy, uTextureClamp.zw);\"\r\n    },\r\n    {\r\n        //DOES HAVE translationMatrix\r\n        vertUniforms: \"uniform mat3 uTransform;\",\r\n        vertCode: \"vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;\",\r\n        fragUniforms: \"\",\r\n        fragCode: \"vec2 textureCoord = vTextureCoord;\"\r\n    },\r\n    {\r\n        //DOES HAVE translationMatrix\r\n        vertUniforms: \"uniform mat3 uTransform;\",\r\n        vertCode: \"vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;\",\r\n        fragUniforms: \"uniform mat3 uMapCoord;\\nuniform vec4 uClampFrame;\\nuniform vec2 uClampOffset;\",\r\n        fragCode: \"vec2 textureCoord = mod(vTextureCoord - uClampOffset, vec2(1.0, 1.0)) + uClampOffset;\" +\r\n        \"\\ntextureCoord = (uMapCoord * vec3(textureCoord, 1.0)).xy;\" +\r\n        \"\\ntextureCoord = clamp(textureCoord, uClampFrame.xy, uClampFrame.zw);\"\r\n    }\r\n];\r\n\r\nPictureShader.prototype = Object.create(PIXI.Shader.prototype);\r\nPictureShader.prototype.constructor = PictureShader;\r\nmodule.exports = PictureShader;\r\n","/**\r\n * A Sprite with reduced border artifacts\r\n *\r\n * @class\r\n * @extends PIXI.Sprite\r\n * @memberof PIXI.extras\r\n * @param texture {PIXI.Texture} the texture for this sprite\r\n */\r\nfunction PictureSprite(texture)\r\n{\r\n    PIXI.Sprite.call(this, texture);\r\n}\r\n\r\nPictureSprite.prototype = Object.create(PIXI.Sprite.prototype);\r\nPictureSprite.prototype.constructor = PictureSprite;\r\nmodule.exports = PictureSprite;\r\n\r\n/**\r\n * Renders the object using the WebGL renderer\r\n *\r\n * @param renderer {PIXI.WebGLRenderer}\r\n * @private\r\n */\r\nPictureSprite.prototype._renderWebGL = function (renderer)\r\n{\r\n    if (this.updateGeometry) {\r\n        this.updateGeometry();\r\n    } else {\r\n        this.calculateVertices();\r\n    }\r\n\r\n    //use different plugin for rendering\r\n    renderer.setObjectRenderer(renderer.plugins.picture);\r\n    renderer.plugins.picture.render(this);\r\n};\r\n","/**\r\n * A TilingSprite with support of additional blendModes\r\n *\r\n * @class\r\n * @extends PIXI.extras.TilingSprite\r\n * @memberof PIXI.extras\r\n * @param texture {PIXI.Texture} the texture for this sprite\r\n * @param {number} width width\r\n * @param {number} height height\r\n */\r\nfunction PictureTilingSprite(texture, width, height)\r\n{\r\n    PIXI.extras.TilingSprite.call(this, texture, width, height);\r\n}\r\n\r\nPictureTilingSprite.prototype = Object.create(PIXI.extras.TilingSprite.prototype);\r\nPictureTilingSprite.prototype.constructor = PictureTilingSprite;\r\nmodule.exports = PictureTilingSprite;\r\n\r\n/**\r\n * Renders the object using the WebGL renderer\r\n *\r\n * @param renderer {PIXI.WebGLRenderer}\r\n * @private\r\n */\r\nPictureTilingSprite.prototype._renderWebGL = function (renderer)\r\n{\r\n    if (this.updateGeometry) {\r\n        this.updateGeometry();\r\n    }\r\n\r\n    const texture = this._texture;\r\n\r\n    if (!texture || !texture.valid)\r\n    {\r\n        return;\r\n    }\r\n\r\n    this.tileTransform.updateLocalTransform();\r\n    this.uvTransform.update();\r\n\r\n    renderer.setObjectRenderer(renderer.plugins.picture);\r\n    renderer.plugins.picture.render(this);\r\n};\r\n","var CONST = PIXI,\r\n    OverlayShader = require('./OverlayShader'),\r\n    HardLightShader = require('./HardLightShader');\r\n\r\n/**\r\n * Maps gl blend combinations to WebGL\r\n * @class\r\n * @memberof PIXI.extras\r\n */\r\nfunction mapFilterBlendModesToPixi(gl, array)\r\n{\r\n    array = array || [];\r\n\r\n    //TODO - premultiply alpha would be different.\r\n    //add a boolean for that!\r\n    array[CONST.BLEND_MODES.OVERLAY] = [new OverlayShader(gl, 0), new OverlayShader(gl, 1), new OverlayShader(gl, 2)];\r\n    array[CONST.BLEND_MODES.HARD_LIGHT] = [new HardLightShader(gl, 0), new HardLightShader(gl, 1), new HardLightShader(gl, 2)];\r\n\r\n    return array;\r\n}\r\n\r\nmodule.exports = mapFilterBlendModesToPixi;\r\n","var myPlugin = {\r\n    PictureSprite: require('./PictureSprite'),\r\n    PictureTilingSprite: require('./PictureTilingSprite'),\r\n    PictureRenderer: require('./PictureRenderer')\r\n};\r\n\r\n//dump everything into extras\r\n\r\nObject.assign(PIXI.extras, myPlugin);\r\n\r\nmodule.exports = myPlugin;\r\n"],"sourceRoot":"/source/"}